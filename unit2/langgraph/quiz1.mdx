# LangGraph 이해도 테스트

지금까지 학습한 `LangGraph`의 주요 개념을 강화하기 위해 빠른 퀴즈로 여러분의 이해도를 테스트해 보겠습니다!

이 퀴즈는 선택 사항이며 점수가 매겨지지 않습니다.

### Q1: LangGraph의 주요 목적은 무엇인가요?
LangGraph가 무엇을 위해 설계되었는지 가장 잘 설명하는 문장은 무엇인가요?

<Question
choices={[
  {
    text: "LLM을 포함하는 애플리케이션의 제어 흐름을 구축하기 위한 프레임워크",
    explain: "정답입니다! LangGraph는 특별히 LLM을 사용하는 애플리케이션의 제어 흐름을 구축하고 관리하는 데 도움을 주기 위해 설계되었습니다.",
    correct: true
  },
  {
    text: "다양한 LLM 모델과 상호작용하기 위한 인터페이스를 제공하는 라이브러리",
    explain: "이는 모델 상호작용을 위한 표준 인터페이스를 제공하는 LangChain의 역할을 더 잘 설명합니다. LangGraph는 제어 흐름에 중점을 둡니다.",
  },
  {
    text: "도구 호출을 위한 에이전트 라이브러리",
    explain: "LangGraph는 에이전트와 함께 작동하지만, langGraph의 주요 목적은 '조율(Orchestration)'입니다.",
  }
]}
/>

---

### Q2: "제어 vs 자유" 트레이드오프의 맥락에서, LangGraph는 어디에 위치하나요?
에이전트 설계에 대한 LangGraph의 접근 방식을 가장 잘 특징짓는 문장은 무엇인가요?

<Question
choices={[
  {
    text: "LangGraph는 자유를 최대화하여 LLM이 모든 결정을 독립적으로 내릴 수 있게 합니다",
    explain: "LangGraph는 실제로 자유보다는 제어에 더 중점을 두며, LLM 워크플로우에 구조를 제공합니다.",
  },
  {
    text: "LangGraph는 의사 결정을 위해 LLM 기능을 활용하면서도 실행 흐름에 대한 강력한 제어를 제공합니다",
    explain: "정답입니다! LangGraph는 구조화된 워크플로우를 통해 예측 가능한 동작을 제공하면서, 에이전트의 실행에 대한 제어가 필요할 때 빛을 발합니다.",
    correct: true
  },
]}
/>

---

### Q3: LangGraph에서 상태(State)는 어떤 역할을 하나요?
LangGraph에서 상태에 대한 가장 정확한 설명을 선택하세요.

<Question
choices={[
  {
    text: "상태는 LLM에서 생성된 최신 결과입니다",
    explain: "상태는 LangGraph에서 사용자 정의 클래스이며, LLM에서 생성된 것이 아닙니다. 필드는 사용자가 정의하며, 값은 LLM이 채울 수 있습니다.",
  },
  {
    text: "상태는 실행 중 오류를 추적하는 데만 사용됩니다",
    explain: "상태는 단순히 오류 추적보다 훨씬 더 넓은 목적을 가지고 있습니다. 하지만 그것도 여전히 유용합니다.",
  },
  {
    text: "상태는 에이전트 애플리케이션을 통해 흐르는 정보를 나타냅니다",
    explain: "정답입니다! 상태는 LangGraph의 중심이며 단계 간 의사 결정에 필요한 모든 정보를 포함합니다. 계산에 필요한 필드를 제공하면 노드가 값을 변경하여 분기를 결정할 수 있습니다.",
    correct: true
  },
  {
    text: "상태는 외부 API와 작업할 때만 관련이 있습니다",
    explain: "상태는 외부 API와 작업하는 애플리케이션뿐만 아니라 모든 LangGraph 애플리케이션의 기본입니다.",
  }
]}
/>

### Q4: LangGraph에서 조건부 엣지(Conditional Edge)란 무엇인가요?
가장 정확한 설명을 선택하세요.

<Question
choices={[
    {
    text: "조건을 평가하여 다음에 실행할 노드를 결정하는 엣지",
    explain: "정답입니다! 조건부 엣지를 통해 그래프는 현재 상태를 기반으로 동적 라우팅 결정을 내릴 수 있으며, 워크플로우에 분기 로직을 만들 수 있습니다.",
    correct: true
  },
  {
    text: "특정 조건이 발생할 때만 따르는 엣지",
    explain: "조건부 엣지는 입력이 아닌 출력에 따라 애플리케이션의 흐름을 제어합니다.",
  },
  {
    text: "진행하기 전에 사용자 확인이 필요한 엣지",
    explain: "조건부 엣지는 사용자 상호작용 요구사항이 아닌 프로그래밍 조건에 기반합니다.",
  }
]}
/>

---

### Q6: LangGraph는 LLM의 환각(hallucination) 문제를 어떻게 해결하는 데 도움이 되나요?
가장 좋은 답변을 선택하세요.

<Question
choices={[
  {
    text: "LangGraph는 LLM 응답을 제한함으로써 환각을 완전히 제거합니다",
    explain: "어떤 프레임워크도 LLM의 환각을 완전히 제거할 수 없으며, LangGraph도 예외가 아닙니다.",
  },
  {
    text: "LangGraph는 LLM 출력을 검증하고 확인할 수 있는 구조화된 워크플로우를 제공합니다",
    explain: "정답입니다! 검증 단계, 확인 노드 및 오류 처리 경로가 있는 구조화된 워크플로우를 만들어 LangGraph는 환각의 영향을 줄이는 데 도움이 됩니다.",
    correct: true
  },
  {
    text: "LangGraph는 환각에 아무런 영향을 미치지 않습니다",
    explain: "LangGraph의 워크플로우에 대한 구조적 접근 방식은 속도를 희생하면서 환각을 크게 완화하는 데 도움이 될 수 있습니다.",
  }
]}
/>

퀴즈를 완료한 것을 축하합니다! 🎉 질문을 놓쳤다면, 이해를 강화하기 위해 이전 섹션을 검토해 보세요. 다음으로, LangGraph의 더 고급 기능을 살펴보고 더 복잡한 에이전트 워크플로우를 구축하는 방법을 알아보겠습니다. 